use std::cmp::max;

use ark_bls12_381::{G1Projective, G1Affine, G2Affine, Fr, Bls12_381};
use ark_ec::group::Group;
use ark_ec::{bls12::Bls12, PairingEngine, ProjectiveCurve, AffineCurve};
use ark_ff::Field;
use ark_poly::{GeneralEvaluationDomain, EvaluationDomain, univariate::DensePolynomial, UVPolynomial};
use ark_poly_commit::kzg10::{Powers, KZG10};
use ark_std::{UniformRand, One};
use merlin::Transcript;

use crate::tools::{trim, commit};
use crate::transcript::*;

type UniPoly381 = DensePolynomial<<Bls12_381 as PairingEngine>::Fr>;
type KzgBls12_381 = KZG10<Bls12_381, UniPoly381>;

pub struct Proof {
    // Prover's Pedersen commitment to their value
    cm: G1Affine,

    // proof of opening of Pedersen commitment (Section 4.7)
    R: G1Affine,
    c: Fr,
    t1: Fr,
    t2: Fr,

    // proof of blinded evaluation (Section 6.1)
    z_comm: G2Affine,
    T_comm: G1Affine,
    S_comm: G2Affine,
}

pub struct Setup {
    // multiplicative subgroup H
    domain: GeneralEvaluationDomain<Fr>,

    // generator of Group 1
    g1: G1Affine,

    // generator of Group 2
    g2: G2Affine,

    // generator of Group 2 times the secret used in KZG setup
    xg2: G2Affine,

    // common point used in Pedersen Hash. For randomness `r`, Ped_r(v) = v*[g1] + r*[h]
    h: G1Affine,

    // KZG SRS: {g1, x*g1, x^2*g1, ..., x^{2^k}*g1}
    ck: Powers<'static, Bls12<ark_bls12_381::Parameters>>,
}

pub fn setup(n: usize) -> Setup {
    let rng = &mut rand::thread_rng();

    let domain: GeneralEvaluationDomain<Fr> = GeneralEvaluationDomain::new(n + 2).unwrap();

    let ck_size = max(n, 2 * domain.size() + 3);

    let srs = KzgBls12_381::setup(max(n, ck_size), true, rng).unwrap();

    // trim down to size.
    let (ck, vk) = trim::<Bls12_381, UniPoly381>(srs, ck_size);

    let g1: G1Affine = ck.powers_of_g[0];
    let g2: G2Affine = vk.h;
    let xg2: G2Affine = vk.beta_h;
    let h: G1Affine = G1Projective::rand(rng).into_affine();

    Setup {
        domain,
        g1,
        g2,
        xg2,
        h,
        ck,
    }
}

pub fn prove(setup: &Setup, entries: &[Fr], index: usize, value: Fr) -> Proof {
    let rng = &mut rand::thread_rng();

    let domain = setup.domain;
    let g1 = setup.g1;
    let g2 = setup.g2;
    let xg2 = setup.xg2;
    let h = setup.h;
    let ck = &setup.ck;

    let mut transcript = Transcript::new(b"caulk_single_open_transcript");

    // add setup information to transcript
    append(&mut transcript, b"domain_generator", domain.element(1));
    append(&mut transcript, b"group_1_generator", g1);
    append(&mut transcript, b"group_1_generator_next", ck.powers_of_g[1]);
    append(&mut transcript, b"group_2_generator", g2);
    append(&mut transcript, b"group_2_generator_next", xg2);
    append(&mut transcript, b"pedersen_base", h);

    // Lagrange basis polynomial encoding the entries
    let C_poly = DensePolynomial::from_coefficients_vec(domain.ifft(entries));
    let C_comm = commit(&C_poly, &setup.ck).into_projective();

    // hash in commitment to public table
    append(&mut transcript, b"commitment_to_public_table", C_comm);

    // Prover's computes `cm` which is a Pedersen commitment to `value` using randomness `r`
    //  cm = value*[g1] + r*[h]
    let r = Fr::rand(rng);
    let cm = pedersen_commit(value, r, g1, h);

    append(&mut transcript, b"value_commitment", cm);

    // Prover picks s1 and s2 randomly for Proof of Opening of a Pedersen Commitment
    let s1 = Fr::rand(rng);
    let s2 = Fr::rand(rng);

    let R = pedersen_commit(s1, s2, g1, h);
    append(&mut transcript, b"commitment_to_opening_challenges", R);

    // hash of commitments cm and R (generated by transcript hash)
    let c: Fr = challenge_scalar(&mut transcript, b"ped_opening_hash");
    append(&mut transcript, b"ped_opening_hash", c);
    
    let t1: Fr = s1 + value*c;
    let t2: Fr = s2 + r*c;

    // prover chooses random `a` and `s`
    let a = Fr::rand(rng);
    let s = Fr::rand(rng);

    // prover computes q, T, and S
    let v_poly = DensePolynomial::from_coefficients_vec(vec![value]);
    let d_poly = DensePolynomial::from_coefficients_vec(vec![-domain.element(index), Fr::one()]);
    let q_poly = &(&C_poly - &v_poly) / &d_poly;

    // Prover computes commitment to `q`
    let q_comm = commit(&q_poly, ck);

    // Prover computes commitment to `T` in group 1
    // [T]_1 = [a^(-1)*q + s*h]_1 = a^(-1)*[q]_1 + s*[h]_1
    let T_comm = (q_comm.mul(a.inverse().unwrap()) + h.mul(s)).into_affine();

    // Prover computes commitment to `z` in group 2
    // [z]_2 = [a(X-omega^i)]_2 = a*[X]_2 - a*omega^i[1]_2
    let z_comm = (xg2.mul(a) - g2.mul(a * domain.element(index))).into_affine();

    // Prover computes commitment to `S` in group 2
    // [S]_2 = [-r - s*z]_2
    let S_comm = (g2.mul(-r) - z_comm.mul(s)).into_affine();

    Proof {
        cm,
        R,
        c,
        t1,
        t2,
        z_comm,
        T_comm,
        S_comm,
    }
}

pub fn verify(setup: &Setup, entries: &[Fr], proof: Proof) -> bool {

    let domain = setup.domain;
    let g1 = setup.g1;
    let g2 = setup.g2;
    let xg2 = setup.xg2;
    let h = setup.h;
    let ck = &setup.ck;

    let cm = proof.cm;

    let R = proof.R;
    let c = proof.c;
    let t1 = proof.t1;
    let t2 = proof.t2;

    let T_comm = proof.T_comm;
    let z_comm = proof.z_comm;
    let S_comm = proof.S_comm;

    let mut transcript = Transcript::new(b"caulk_single_open_transcript");

    // add setup information to transcript
    append(&mut transcript, b"domain_generator", domain.element(1));
    append(&mut transcript, b"group_1_generator", g1);
    append(&mut transcript, b"group_1_generator_next", ck.powers_of_g[1]);
    append(&mut transcript, b"group_2_generator", g2);
    append(&mut transcript, b"group_2_generator_next", xg2);
    append(&mut transcript, b"pedersen_base", h);

    // Lagrange basis polynomial encoding the entries
    let C_poly = DensePolynomial::from_coefficients_vec(setup.domain.ifft(entries));
    let C_comm = commit(&C_poly, &setup.ck).into_projective();

    // hash in commitment to public table
    append(&mut transcript, b"commitment_to_public_table", C_comm);

    // hash in prover's value commitment
    append(&mut transcript, b"value_commitment", proof.cm);

    // verify opening of pedersen commitment
    let opening_verified = (R + cm.mul(c).into_affine() == pedersen_commit(t1, t2, g1, h));


    // verify blinded evaluation
    let pairing_left = Bls12_381::pairing(C_comm - cm.into_projective(), g2);
    let pairing_right = Bls12_381::pairing(T_comm, z_comm) * Bls12_381::pairing(h, S_comm);
    let blinded_evaluation_verified = (pairing_left == pairing_right);

    opening_verified && blinded_evaluation_verified
}


fn pedersen_commit<G>(a: Fr, b: Fr, base_gen: G, ped_gen: G ) -> G
    where
        G: AffineCurve<ScalarField = Fr>,

{
    (base_gen.mul(a) + ped_gen.mul(b)).into_affine()
}


#[cfg(test)]
mod tests {
    use ark_bls12_381::Fr;
    use crate::single::*;

    #[test]
    pub(crate) fn test_single_opening() {
        let rng = &mut rand::thread_rng();

        let num_of_entries = 100;

        // we have a list of field elements
        let entries: Vec<Fr> = (0..num_of_entries)
            .into_iter()
            .map(|_i| Fr::rand(rng))
            .collect();

        let setup = setup(num_of_entries);

        // the Prover owns the entry at index 47
        let prover_entry_index = 47usize;
        let prover_entry = entries[prover_entry_index];

        // Prover constructs a proof which contains a hiding Pedersen commitment to their entry
        let proof = prove(&setup, &entries, prover_entry_index, prover_entry);

        // Verifier verifies the Prover's Pedersen commitment corresponds to some entry in the list
        let result = verify(&setup, &entries, proof);

        //  NOTE: as currently written the verifier code is incomplete
        //  TODO:
        //      - verify pedersen commitment opening as in Section 4.7
        //      - verify that z_comm is correctly constructed as in Section 6.2

        assert!(result)
    }

}